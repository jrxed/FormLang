# Задача

Даны $\alpha$ и буква $x$. Найти максимальное $k$, такое что в $L$ есть слова,
содержащие $x^k$.

# Описание алгоритма

Разделим все слова из $\{a, b, c\}^*$ на 5 классов:
0) Содержащие в себе максимум $k$ символов $x$ подряд, но не начинающиеся и не
заканчивающиеся на $x$, не равные пустому слову (здесь $k$ может быть 0)
1) Начинающиеся на $k \neq 0$ подряд идущих символов $x$, но не заканчивающиеся на $x$
2) Заканчивающиеся на $k \neq 0$ подряд идущих символов $x$, но не начинающихся на $x$
3) Состоящие только из $k \neq 0$ символов $x$
4) Пустое слово $\epsilon$

Очевидно, что любое слово из $L$ мы можем однозначно определить в
одну из этих групп.

Вернемся к задаче: необходимо максимизировать $k$. Будем читать обратную
польскую нотацию, попутно изменяя ответ. Для этого создадим
экземпляр класса $Counter$, в котором будем хранить 4 числа -
максимальные $k$ для каждого из классов 0-3 слов, которые принадлежат
языку, регулярное выражение для которого мы уже разобрали, а также
флаг - могли ли мы на текущем шаге получить пустое слово.
Каждому объекту $Counter$ сопоставим массив $arr$ из этих 4 чисел,
а также флаг $contains\_empty$, обозначающий, есть ли в языке пустое слово.

Как выглядит построение?

## База

Если 1 символ и он равен нужному, то имеем $[0, 0, 0, 1]$, если не равен,
то $[0, 0, 0, 0]$

Если символ равен пустому слову, то $arr = [0, 0, 0, 0]$, также
ставим $contains\_empty = True$, иначе $contains\_empty = False$

## Переход

### $*$

Если $arr[3] \neq 0$, то применение операции $*$ позволит построить слово, состоящее из
любого количества идущих подряд символов $x$; если при этом $arr[1] \neq 0$, то можем
построить слово с префиксом из любого количества подряд идущих символов $x$, аналогично
с суффиксом, если $arr[2] \neq 0$; если одновременно $arr[1] \neq 0$ и $arr[2] \neq 0$, то
$arr[0]$ также перейдет в $\infty$.

Возможен случай, когда берутся 2 слова $v$, $u$, такие что $v$ принадлежит второму
классу  и начинается на $k_v$ символов $x$ подряд, а $u$ принадлежит третьему классу
и заканчивается на $k_u$ символов $x$ подряд. Тогда новое значение $arr[0]$ станет
равным $max(arr[0], k_u + k_v)$, то есть $max(arr[0], arr[1] + arr[2])$, где
$arr[1] \neq 0$ и $arr[2] \neq 0$

### $+$
 
При примении операции $+$ множества слов, соответствующие двум регулярным выражениям
$r_1$ и $r_2$, объединяются и их объединение соответствует выражению $r_1 + r_2$.
Тогда ясно, что описанные выше классы тоже подчиняются этому правилу, поэтому,
чтобы получить значения $arr_+[i]$ для $r_1 + r_2$, достаточно взять максимум из
двух значений $arr_1[i]$ и $arr_2[i]$, которые соответствуют $r_1$ и $r_2$.

Если хотя бы одно из множеств содержит пустое слово, то и объединение
содержит пустое слово.

### $.$

При реализации конкатенации множеств достаточно рассмотреть случаи, слова из каких классов
были взяты для конкатенации слов и какой класс тогда можно обновить:

- $k_1$ из класса 0, $k_2$ из класса 0, тогда $arr[0]=max(arr[0], k_1, k_2)$
- $k_1$ из класса 0, $k_2$ из класса 1, тогда $arr[0]=max(arr[0], k_1, k_2)$
- $k_1$ из класса 0, $k_2$ из класса 2, тогда $arr[0]=max(arr[0], k_1)$, $arr[2]=max(arr[2], k_2)$
- $k_1$ из класса 0, $k_2$ из класса 3, тогда $arr[2]=max(arr[2], k_2)$
- $k_1$ из класса 1, $k_2$ из класса 0, тогда $arr[0]=max(arr[0], k_2)$, $arr[1]=max(arr[1], k_1)$
- $k_1$ из класса 1, $k_2$ из класса 1, тогда $arr[0]=max(arr[0], k_2)$, $arr[1]=max(arr[1], k_1)$
- $k_1$ из класса 1, $k_2$ из класса 2, тогда $arr[1]=max(arr[1], k_1)$, $arr[2]=max(arr[2], k_2)$
- $k_1$ из класса 1, $k_2$ из класса 3, тогда $arr[1]=max(arr[1], k_1)$, $arr[2]=max(arr[2], k_2)$
- $k_1$ из класса 2, $k_2$ из класса 0, тогда $arr[0]=max(arr[0], k_1, k_2)$
- $k_1$ из класса 2, $k_2$ из класса 1, тогда $arr[0]=max(arr[0], k_1 + k_2)$
- $k_1$ из класса 2, $k_2$ из класса 2, тогда $arr[0]=max(arr[0], k_1)$, $arr[2]=max(arr[2], k_2)$
- $k_1$ из класса 2, $k_2$ из класса 3, тогда $arr[2]=max(arr[2], k_1 + k_2)$
- $k_1$ из класса 3, $k_2$ из класса 0, тогда $arr[0]=max(arr[0], k_2)$, $arr[1]=max(arr[1], k_1)$
- $k_1$ из класса 3, $k_2$ из класса 1, тогда $arr[1]=max(arr[1], k_1 + k_2)$
- $k_1$ из класса 3, $k_2$ из класса 2, тогда $arr[1]=max(arr[1], k_1)$, $arr[2]=max(arr[2], k_2)$
- $k_1$ из класса 3, $k_2$ из класса 3, тогда $arr[3]=max(arr[3], k_1 + k_2)$

Если какое-то из множеств содержит пустое слово, то для поддержания
правильного ответа надо будет в итоговом $arr[]$ для каждого индекса $i$
записать $arr[i] = max(arr[i], arr'[i])$, где $arr'[]$ соответствует
другому множеству (потому что слова из другого множества мы можем просто
проигнорировать). Если оба множества содержат пустое слово, такую
операцию надо проделать с обоими множествами.

## Получение ответа

Теперь, когда у нас посчитан $arr$ для всего регулярного выражения, достаточно взять по нему
максимум - это и будет ответом.

## Примечание

Классы можно ввести и по-другому:
0) Содержащие в себе максимум $k$ символов $x$ подряд
1) Начинающиеся на $k \neq 0$ подряд идущих символов $x$
2) Заканчивающиеся на $k \neq 0$ подряд идущих символов $x$
3) Состоящие только из $k \neq 0$ символов $x$
4) Пустое слово $\epsilon$

Очевидно, что теперь, например, класс 3 вложен во все остальные классы. На работу алгоритма и
на ответ это никак не влияет, но таким образом можно немного упростить реализацию конкатенации,
убрав пару проверок на то, что рассматриваемый класс непуст.

# Почему алгоритм работает корректно

Корректность алгоритма следует из корректности базы (1 символ из алфавита)
и переходов (применение операций ${*, ., +}$) и того, что при каждом переходе мы
поддерживаем следующий инвариант: из каждого класса хранится по 1 представителю с наибольшим $k$.
Так как каждое слово из $L$ принадлежит хотя бы одному классу и объединение всех классов
принадлежит $L$, то $k$ - ответ $ \iff $ $k$ - максимум по всем $k$ из классов.

# Асимптотика

Как следует из написанного выше, символ из алфавита и пустое слово мы
разбираем за $O(1)$, применение операций ${*, ., +}$ - это разбор
константного числа случаев, каждый из которых обрабатывается за $O(1)$,
поэтому тоже $O(1)$, а значит время работы программы оценивается как
$|\alpha| * O(1) = O(|\alpha|)$, где $\alpha$ - регулярного выражение,
которое подается на вход.
